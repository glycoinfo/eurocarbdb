/*
*   EuroCarbDB, a framework for carbohydrate bioinformatics
*
*   Copyright (c) 2006-2009, Eurocarb project, or third-party contributors as
*   indicated by the @author tags or express copyright attribution
*   statements applied by the authors.  
*
*   This copyrighted material is made available to anyone wishing to use, modify,
*   copy, or redistribute it subject to the terms and conditions of the GNU
*   Lesser General Public License, as published by the Free Software Foundation.
*   A copy of this license accompanies this distribution in the file LICENSE.txt.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
*   for more details.
*
*   Last commit: $Rev: 1454 $ by $Author: hirenj $ on $Date:: 2009-07-08 #$  
*/
package org.eurocarbdb.dataaccess.core;
// Generated 3/08/2006 16:48:25 by Hibernate Tools 3.1.0.beta4

import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import java.util.Collections;
import java.util.ArrayList;
import java.io.Serializable;

import org.apache.log4j.Logger;

import org.eurocarbdb.util.mesh.MeshReference; 
import org.eurocarbdb.dataaccess.EntityManager;
import static org.eurocarbdb.dataaccess.Eurocarb.getEntityManager;

/**
*   Disease generated by hbm2java
*/
public class Disease extends MeshReference 
implements Serializable, Comparable//, BiologicalContextAssociation
{
    //~~~~~~~~~~~~~~~~~~~~~~ STATIC FIELDS ~~~~~~~~~~~~~~~~~~~~~~~~//

    /** Logging handle. */
    protected static final Logger log 
        = Logger.getLogger( Disease.class );
    
    /** Named query for getting diseases by name or synonym. 
    *   @see the Disease.hbm.xml mapping file.  */
    private static final String Q = Disease.class.getName() + '.';

    /** Disease object that represents the root of the disease hierachy,
    *   which is effectively also equivalent to 'unknown disease'. */
    private static Disease UnknownDisease = null; 
    
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~ FIELDS ~~~~~~~~~~~~~~~~~~~~~~~~~~~//

    private int diseaseId = 0;
    
    private String diseaseName = null;
    
    private String meshId = null;
    
    private String description = null;
    
    private Date dateLastModified = null;
    
    private DiseaseRelations relations = null;
    
    private Set<DiseaseContext> diseaseContexts = new HashSet<DiseaseContext>(0);
    
    private Set<DiseaseSynonym> diseaseSynonyms = new HashSet<DiseaseSynonym>(0);
    
    /** Parent disease of this disease in the Disease hierachy. */
    private Disease parentDisease;

    /** Child diseases of this disease in the Disease hierachy. */
    private Set<Disease> childDiseases = new HashSet<Disease>(0);


    //~~~~~~~~~~~~~~~~~~~~~~ CONSTRUCTORS ~~~~~~~~~~~~~~~~~~~~~~~~~//

    /** default constructor */
    public Disease() {}

    private Disease( String disease_name, String mesh_id )
    {
        //  this is a special case of where the ROOT of the tree is intended
        //  to be self-referential to satisfy the requirement that a 
        //  parent cannot be null.
        if ( parentDisease == null )
            parentDisease = this;
        
        this.diseaseName = disease_name;
        this.meshId = mesh_id;
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~ STATIC METHODS ~~~~~~~~~~~~~~~~~~~~~~~//

    /** 
    *   Returns the disease representing the root of the 
    *   disease hierachy, which is effectively also equivalent 
    *   to the canonical 'unknown' disease. 
    */
    public static Disease UnknownDisease() 
    {
        if ( UnknownDisease == null )
        {
            try
            {
                log.debug("looking up canonical disease root");
                UnknownDisease = getEntityManager().lookup( Disease.class, 1 );
                if ( UnknownDisease == null )
                    throw new RuntimeException(
                        "No root disease (id == 1) in the current data store");
            }
            catch ( Exception e )
            {
                //  mjh: most likely here because there's no data in the 
                //  data store for diseases. for now, complain about it 
                //  and return null. 
                log.warn("Caught " + e + " while looking up root disease:", e );
                return null;
            }
        }
        
        return UnknownDisease;
    }
    

    /*  lookupByMeshId  *//******************************************
    *
    *   Returns the Disease with the given mesh id, or null if nothing
    *   matches.
    *
    *   @throws IllegalArgumentException if the given {@link String}
    *   is not a valid MESH id.
    *   @see MeshReference
    */
    public static Disease lookupByMeshId( String mesh_id )
    {
        if ( mesh_id == null || mesh_id.length() < 3 )
            throw new IllegalArgumentException(
                "Invalid MESH id string '" + mesh_id + "'");
            
        if ( log.isDebugEnabled() )
            log.debug( "looking up disease matching mesh id=" + mesh_id );
            
        EntityManager em = getEntityManager();
        Object result = em.getQuery( Q + "DISEASE_BY_MESH_ID" )
                        .setParameter( "mesh_id", mesh_id )
                        .uniqueResult();
                                            
        return (Disease) result;
    }
    
    
    /*  lookupNameOrSynonym  *//*************************************
    *
    *   Returns the list of diseases whose name or synonym fields 
    *   match the passed search string. Throws an UnsupportedOperationException 
    *   if search string is null or shorter than 3 characters.
    */
    @SuppressWarnings("unchecked")
    public static List<Disease> lookupNameOrSynonym( String search_string )
    throws UnsupportedOperationException
    {
        if ( search_string == null || search_string.length() < 3 )
            throw new UnsupportedOperationException(
                "Disease name/synonym searches of < 3 chars not supported");
            
        if ( log.isDebugEnabled() )
            log.debug( "looking up diseases whose name or synonym matches '" 
                     + search_string 
                     + "'" );
            
        EntityManager em = getEntityManager();
        List result = em.getQuery( Q + "MATCHING_NAME_OR_SYNONYM" )
                        .setParameter( "disease_name", '%' + search_string + '%' )
                        .list();
                                            
        return (List<Disease>) result;
    }

    /** 
    *   Returns a count {@link GlycanSequence}s associated to this
    *   {@link Disease} and all its sub-diseases.
    */
    public int getSubDiseasesGlycanSequenceCount() 
    {
        EntityManager em = getEntityManager();
        try
        {
            Object result = em.getQuery( "org.eurocarbdb.dataaccess.core.Disease." 
                                       + "count_structures_for_this_disease" )
                              .setParameter( "disease_id", this.getDiseaseId() )
                              .list();                              

            if ( result == null ) 
                return 0; 
            
            assert result instanceof List;
            List result_list = (List) result;
        if( result_list.size()==0 )
        return 0;

            return (Integer)result_list.iterator().next();
        }
        catch ( Exception e ) 
        {  
            log.warn( "Caught exception while counting sequences for disease ", e ); 
            return 0;
        }
    }    
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~ METHODS ~~~~~~~~~~~~~~~~~~~~~~~~~~~//

    public int getDiseaseId() 
    {
        return this.diseaseId;
    }
    
    public void setDiseaseId(int diseaseId) 
    {
        this.diseaseId = diseaseId;
    }

    public Disease getParentDisease() 
    {
        return this.parentDisease;
    }
    
    public void setParentDisease( Disease parentDisease ) 
    {
        this.parentDisease = parentDisease;
    }

    public String getDiseaseName() 
    {
        return this.diseaseName;
    }
    
    public void setDiseaseName( String diseaseName ) 
    {
        this.diseaseName = diseaseName;
    }

    public String getMeshId() 
    {
        return this.meshId;
    }
    
    public void setMeshId( String meshId ) 
    {
        this.meshId = meshId;
    }

    public boolean isRootDisease() {
        return this.diseaseName.equals("Diseases"); 
    }
    
    public String getDescription() 
    {
        return this.description;
    }
    
    public void setDescription( String description ) 
    {
        this.description = description;
    }


    public Date getDateLastModified() 
    {
        return this.dateLastModified;
    }
    
    public void setDateLastModified( Date dateLastModified ) 
    {
        this.dateLastModified = dateLastModified;
    }

    public Set<DiseaseContext> getDiseaseContexts() 
    {
        return this.diseaseContexts;
    }
    
    public void setDiseaseContexts( Set<DiseaseContext> diseaseContexts ) 
    {
        this.diseaseContexts = diseaseContexts;
    }

    public Set<DiseaseSynonym> getDiseaseSynonyms() 
    {
        return this.diseaseSynonyms;
    }
    
    public void setDiseaseSynonyms( Set<DiseaseSynonym> diseaseSynonyms ) 
    {
        this.diseaseSynonyms = diseaseSynonyms;
    }

    
    public DiseaseRelations getRelations() 
    {
        return this.relations;
    }
    
    /**
    *
    *   
    */
    public void setRelations( DiseaseRelations relations ) 
    {
        this.relations = relations;
    }

    
    public Set<Disease> getChildDiseases() 
    {
        return this.childDiseases;
    }
    
    
    public void setChildDiseases( Set<Disease> childDiseases ) 
    {
        this.childDiseases = childDiseases;
    }
   

    /*  getAllParentDiseases  *//************************************
    *
    *   Returns a list of all the parent diseases of this
    *   disease up to the root of the hierachy such that the root
    *   disease will be element 0, and the immediate parent of 
    *   this disease as the last element in the list. Returns an
    *   empty list if this disease has no parents.
    *
    *   @author mjh
    */
    public List<Disease> getAllParentDiseases()
    {
        List<Disease> list = new ArrayList<Disease>();
        Disease cursor = this.getParentDisease();
        
        while ( cursor != null )
        {
            list.add( 0, cursor );
            cursor = cursor.getParentDisease();
            if ( list.get( 0 ) == cursor ) break;   
        }
         
        return list;
    }

    public List<Object[]> getListOfSubDiseasesGlycanSequenceCount() 
    {
        EntityManager em = getEntityManager();
        try
        {
            Object result = em.getQuery( Disease.class.getName()
                                       + ".count_structures_for_sub_diseases" )
                              .setComment( "Disease.getListOfSubDiseasesGlycanSequenceCount")
                              .setParameter( "disease_id", this.getDiseaseId() )
                              .list();
                              
            if ( result == null ) 
                return Collections.emptyList(); 
            
            assert result instanceof List;
            List<Object[]> result_list = (List<Object[]>) result;
            
            return result_list;
        }
        catch ( Exception e ) 
        {  
            log.warn( "Caught exception while counting sequences for disease", e ); 
            return Collections.emptyList();//Collections.emptyMap();
        }
              
    }
    
    
    public int compareTo( Object obj )
    {
        return this.toString().compareTo( obj.toString() );
    }
    
    
    /** Returns true if this Disease is the root of the Disease hierachy. */
    public boolean isRoot()
    {
        return this.diseaseId == 1;
    }
    
    
    public String toString()
    {
        return this.getDiseaseName();
    }
    

} // end class
