/*    iupac_grammar.g -- a grammar for carbohydrates in IUPAC nomenclature    */


header //  <-- this section appears at the top of the auto-generated parser
{   
package org.eurocarbdb.sugar.seq.grammar; 

import org.eurocarbdb.sugar.seq.grammar.IupacParserAdaptor;
import org.eurocarbdb.sugar.seq.grammar.ParserAdaptor;
import org.eurocarbdb.sugar.seq.grammar.ResidueToken;
import org.eurocarbdb.sugar.seq.grammar.LinkageToken;

}


/*  class IupacParser  *//*****************************************************
*<p>
*   This class defines an LLk parser based on ANTLR (http://antlr.org) syntax 
*   rules for parsing carbohydrate sequences in extended IUPAC syntax, according 
*   to the syntax rules described (TODO: provide a definitive syntax reference link). 
*</p>
*<p>
*   This class inherits from 2 superclasses, which provide the majority of 
*   the semantic action code that is called from within this grammar. This
*   is in order to keep the grammar as clear as possible and to facillitate
*   re-targeting of this grammar to other languages than Java (at time of 
*   writing ANTLR also supports C++, python, C#).
*</p>
*<p>
*   Note that the source code for this class has been auto-generated by ANTLR.
*</p>
*
*   @see IupacLexer
*   @see IupacParserAdaptor
*   @see ParserAdaptor
*   @see iupac_grammar.g
*
*   @author mjh
*/
class IupacParser extends Parser("org.eurocarbdb.sugar.seq.grammar.IupacParserAdaptor");

//  ANTLR options
options {
    k=3;                        /* lookahead */
    codeGenDebug=false;         /* a debugging setting */
    analyzerDebug=false;        /* a debugging setting */
    defaultErrorHandler=false;  /* needs to be false to propagate exceptions */
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GRAMMAR ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                                              |                              |
//          grammar-specification               |      actions for grammar     |
//            written in antlr                  |        written in java       |
//                                              |                              |
//                                              |                              |

/** Toplevel rule defining a sugar sequence.  */
sugar       
        :   (linked_residue)*     
            root_monosaccharide 
            (NEWLINE)?!
        ; 
                                                
/** Rule for the root monosaccharide in a sequence.  */
root_monosaccharide                             {   ResidueToken m = null;  }
        :   m=monosaccharide                    {   addRootResidue( m );    }
        ;
                                                        
/** 
*   Parent rule for anything attached to the root monsaccharide, specifically
*   residue_linkage pairs, and any branches.
*/
linked_residue          
        :   residue_linkage_pair (branch)*
        ;

/**
*   Specifies a residue-linkage pair. Residues are always associated with 
*   just one linkage on their reducing terminal (right) side, and both of 
*   these are <em>typed</em>; that is, a residue may be a 
*   <em>monosaccharide</em>, <em>substituent</em>, or a <em>repeat</em>.
*/
residue_linkage_pair    
        :   linked_monosaccharide   
        |   linked_substituent      
        |   linked_repeat           
        ; 
         

/** Rule for a "regular" monosaccharide/linkage pair. */                    
linked_monosaccharide                           {   LinkageToken lt = null; ResidueToken mt = null;  }
        :   mt=monosaccharide  
            lt=monosaccharide_linkage           {   addLinkedResidue( mt, lt );  }
        ;

/** 
*   Rule for a substituent/linkage pair. A substituent is anything that 
*   is not a monosaccharide.
*/                  
linked_substituent                              {   ResidueToken st = null; LinkageToken lt = null;  }
        :   st=substituent
            lt=substituent_linkage              {   addLinkedResidue( st, lt );  }
        ;
                                    
/** 
*   Rule for a repeat/linkage pair. Repeats are effectively regarded as a 
*   repeated "sub-sugar" within a sugar, along with additional information 
*   about the number of repeats.  */                    
linked_repeat                                   {   LinkageToken lt = null;   }
        :   repeat_unit
            lt=monosaccharide_linkage           {   /* TODO: handle repeats */  }
        ;


/** 
*   Defines a repeat unit. A repeat unit is effectively a sub-structure within
*   a larger sugar that may be repeated a definite or variable number of times. 
*   Repeat units consist of an optional range specification, followed by any 
*   number of <code>linked_residue</code>s, all enclosed by repeat delimiters '{}'. 
*/
repeat_unit                                     {   ResidueToken m = null;  }
        :   OPENING_REPEAT_DELIM
            (repeat_range)?
            (linked_residue)+
            m=monosaccharide
            CLOSING_REPEAT_DELIM                {   /* todo: handle repeats */  }
        ;

/** Rule for a repeat range, of form "10-20:". */                   
repeat_range            
        :   lower:NUMBER
            (INTERNAL_DELIM  upper:NUMBER)?  
            REPEAT_RANGE_DELIM                  {   checkRepeatBounds( lower, upper );  }
        ;

/** 
*   Rule for a branch. Branches are effectively sugar subsequences enclosed 
*   by the branch delimiters '[]'. Branches cannot be "empty". 
*/
branch                  
        :   b1:OPENING_BRANCH_DELIM             {   branchStarts();  }
            (linked_residue)+  
            b2:CLOSING_BRANCH_DELIM             {   branchEnds();    }
        ;

/** 
*   Rule for a monosaccharide linkage. In their most basic form, 
*   monosaccharide linkages consist of an <em>anomer</em>, a <em>reducing 
*   terminus</em>, and a <em>non-reducing terminus</em>, enclosed by the 
*   linkage delimiters '()'. Monosaccharide (and other) linkages may also 
*   contain <em>unknown elements</em> '?', <em>alternation</em> '|', and/or 
*   have <em>multiconnections</em>.
*<br/>
*   Example: "Hex(a1-4)Hex" 
*/
monosaccharide_linkage                          returns [ LinkageToken lt = null ] 
                                                {   Token anom, parent = null, child = null; LinkageToken mlink = null; }
        :   
        o:OPENING_LINKAGE_DELIM 
        anom=anomer
        child=reducing_terminus 
        h:INTERNAL_DELIM
        // NRT may not be present if next residue is substituent    
        (parent=nonreducing_terminus)?          {   lt = createLinkageToken( anom, parent, child );  }
        (mlink=multiconnected_monosac_linkage)* {   /* MULTI */   }
        c:CLOSING_LINKAGE_DELIM                 {       }
        ;
        
                    
/** 
*   Rule for a substituent linkage. Substituent linkages have similar 
*   characteristics to monosaccharide linkages but do not comprise an 
*   anomeric configuration or reducing terminus.  
*<br/>
*   Example: "P(-4)Glc", "S(-6)Glc"
*/
substituent_linkage                             returns [ LinkageToken lt = null ]  
                                                {  Token parent;  }
        :   INTERNAL_DELIM
        |   o:OPENING_LINKAGE_DELIM
            INTERNAL_DELIM
            parent=nonreducing_terminus
            (multiconnected_substit_linkage)*
            c:CLOSING_LINKAGE_DELIM             {   lt = createLinkageToken( null, parent, null );  }
        ;   

/** 
*   Monosaccharide linkages may be multi-connected, whereby a second 
*   linkage specification appears within the linkage delimiters '()', 
*   separated from other linkage specifications by commas.
*<br/>
*   Example: "NeuAc(a2-8,1-9)NeuAc"
*/
multiconnected_monosac_linkage                  returns [ LinkageToken lt = null ]
                                                {   Token parent = null, child = null;  }  //int term1 = -1, term2 = -1;  }        
        :   COMMA 
            child=nonreducing_terminus 
            INTERNAL_DELIM 
            //  NRT may not be present if next residue is substituent
            (parent=nonreducing_terminus)?    
                                                {   lt = createLinkageToken( null, parent, child );  }
        ;

/** 
*   Substituent linkages may also be potentially multiconnected in the 
*   same manner as multiconnected monosaccharides, with the previously 
*   described limitation that substituent linkages do not comprise an 
*   anomeric configuration. 
*/
multiconnected_substit_linkage                  {   Token child, parent;  } //int term1 = -1, term2 = -1;  }        
        :   COMMA 
            (child=nonreducing_terminus)? 
            INTERNAL_DELIM 
            parent=nonreducing_terminus
        ;
        

/** Rule for a monosaccharide residue name.  */
monosaccharide                                  returns [ ResidueToken rt = null ]
        :   m:RESIDUE                           {   rt = createMonosaccharideToken( m );  }
            // disallow alternation for monosacs for now
            //( LOGICAL_OR RESIDUE )?
        ;


/** Rule for a substituent residue name.  */
substituent                                     returns [ ResidueToken ss = null ]          
        :   s:RESIDUE                           {   ss = createSubstituentToken( s );  }
        ;

/** 
*   Rule for an anomer, specifically 'a' for alpha, 'b' for beta, 
*   or 'u' for unknown. 
*/
anomer                                          returns [ Token anom ]              
        :   a:ANOMER                            {   anom = a;    } 
        |   u:UNKNOWN_ANOMER                    {   anom = null; }
        ;

/** 
*   Rule for a reducing terminal position, ie: any positive integer 
*   greater than zero that is reasonable for the monosaccharide found 
*   on the reducing terminal side of the given linkage.
*/
reducing_terminus                               returns [ Token rterm ]
        :   r:NUMBER                            {   rterm = r;    } 
        |   u:UNKNOWN_TERMINUS                  {   rterm = null; } 
        ;

/** 
*   Rule for a reducing terminal position, ie: any positive integer 
*   greater than zero that is reasonable for the monosaccharide found 
*   on the non-reducing terminal side of the given linkage.
*/
nonreducing_terminus                            returns [ Token nrterm ]
        :   t:NUMBER                            {   nrterm = t;    } 
            ( LOGICAL_OR  NUMBER )* 
        |   u:UNKNOWN_TERMINUS                  {   nrterm = null; } 
        ;
                
                

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LEXER ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*  class IupacLexer  *//**
*
*   This class implements a lexer/scanner for carbohydrate
*   sequences in Iupac syntax. This class was auto-generated from
*   the ANTLR lexer grammar in iupac_grammar.g.
*
*   @see IupacParser
*   @see iupac_grammar.g
*
*   @author mjh [matt@ebi.ac.uk]
*/
class IupacLexer extends Lexer;


OPENING_BRANCH_DELIM    
        options { paraphrase="an opening branch delimiter '['"; }
        :   '[' 
        ;
                        
CLOSING_BRANCH_DELIM    
        options { paraphrase="a closing branch delimiter ']'"; }
        :   ']' 
        ;

OPENING_LINKAGE_DELIM   
        options { paraphrase="an opening linkage delimiter '('"; }
        :   '(' 
        ;
                        
INTERNAL_DELIM          
        options { paraphrase="an internal linkage delimiter '-'"; }
        :   '-' 
        ;

CLOSING_LINKAGE_DELIM   
        options { paraphrase="a closing linkage delimiter ')'"; }
        :   ')' 
        ;

                        
OPENING_REPEAT_DELIM    
        options { paraphrase="an opening repeat delimiter '{'"; }
        :   '{'
        ;

CLOSING_REPEAT_DELIM    
        options { paraphrase="a closing repeat delimiter '}'"; }
        :   '}'
        ;

REPEAT_RANGE_DELIM      
        options { paraphrase="a repeat range delimiter ':'"; }
        :   ':'
        ;

//MONOSACCHARIDE            : 'A'..'Z' ('A'..'Z' | 'a'..'z' | '0'..'9')+ ;
//SUBSTITUENT               : 'A'..'Z' ('A'..'Z' | 'a'..'z' | '0'..'9')+ ;

RESIDUE                 
        options { paraphrase="a residue name"; }
        :   'A'..'Z' ('A'..'Z' | 'a'..'z' | '0'..'9')* 
        ;


ANOMER                  
        options { paraphrase="a linkage anomer"; }
        :   ('a' | 'b' ) 
        ;


UNKNOWN_TERMINUS        
        options { paraphrase="an unknown terminus"; }
        :   '?'
        ;

UNKNOWN_ANOMER
        options { paraphrase="an unknown anomer"; }
        :   'u'
        ;

LOGICAL_OR              
        options { paraphrase="an alternation operator"; }
        :   '|'
        ;
                        
NUMBER
        options { paraphrase="a non-zero terminal position"; }
        :   ('1'..'9')  ('0'..'9')* 
        ;

//  this doesn't work \/
//NUMBER_OR_ZERO
//      options { paraphrase="a number, or zero"; }
//      :   '0' 
//      |   ('1'..'9')  ('0'..'9')* 
//      ;
                        
COMMA               
        options { paraphrase="a comma"; }
        :   ','
        ;

//NONREDUCING_TERMINUS  : ('1'..'9') ;
//REDUCING_TERMINUS     : ('1'..'9') ;

NEWLINE
        :   '\r' '\n'   // DOS
        |   '\n'        // UNIX
        ;
    
    
    
                            
                        