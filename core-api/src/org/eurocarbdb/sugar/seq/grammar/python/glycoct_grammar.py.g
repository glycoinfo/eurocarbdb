/*    glycoct_grammar.g -- a grammar for carbohydrates in GlycoCT format    */


header //  <-- this section appears at the top of the auto-generated parser
{       
}

options 
{
    language="Python";
}

/*    class GlycoctParser  *//*****************************************************
*<p>
*    This class defines an LLk parser based on ANTLR (http://antlr.org) syntax 
*   rules for parsing carbohydrate sequences in GlycoCT syntax, according 
*   to the syntax rules described (TODO: provide a definitive syntax reference link). 
*</p>
*<p>
*   This class' superclass provides the majority of 
*   the semantic action code that is called from within this grammar. This
*   is in order to keep the grammar as clear as possible and to facillitate
*   re-targeting of this grammar to other languages than Java (at time of 
*   writing ANTLR also supports C++, python, C#).
*</p>
*<p>
*   Note that the source code for this class has been auto-generated by ANTLR.
*</p>
*
*   @see GlycoctLexer
*   @see GlycoctParserAdaptor
*   @see ParserAdaptor
*   @see glycoct_grammar.g
*
*    @author mjh [matt@ebi.ac.uk]
*/
class GlycoctParser extends Parser;

//~~~  ANTLR options  ~~~
options {
    k=2;                        /* lookahead */
    codeGenDebug=false;         /* a debugging setting */
    analyzerDebug=false;        /* a debugging setting */
    defaultErrorHandler=false;  /* needs to be false to propagate exceptions */
    buildAST=false;
}

//~~~ start class init section ~~~  
//  this section is inserted directly into the top of the generated class
//  right after the class declaration. It can contain any valid (Java) code. 
{
    /* empty */
}
//~~~ end class init section ~~~  



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GRAMMAR ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                                              |                              |
//          grammar-specification               |      actions for grammar     |
//            written in antlr                  |        written in java       |
//                                              |                              |
//                                              |                              |

/** Toplevel rule defining a sugar sequence.  */
sugar        
        :    res_section        /*  residues  */
            (lin_section)?      /*  linkages  */

//TODO:     (pro_section)?      /*  heterogeneity due to uncertainty  */
//TODO:     (rep_section)?      /*  repeats   */
//TODO: // STA section too incompletely defined grammatically - omitted
//TODO      sta_section         /*  heterogeneity due to statistical distribution, eg GAGs */              
            EOF
        ; 
 
 

//~~~  SECTIONS  ~~~//
        
/** Rule for a RES (residues) section. */        
res_section
        :   RES 
            (residue)+
        ;


/** Rule for a LIN (linkages) section. */        
lin_section
        :   LIN
            (linkage)+
        ;
           
        
/** Rule for a PRO (heterogeneity) section. */        
pro_section
        :   PRO
            (linkage)+
        ;
        
        
/** Rule for the REP (repeats) section. */        
rep_section
        :   REP
            (sugar)+
        ;

        
//~~~  RES SECTION  ~~~//

/** A numbered residue entry in the 'RES' section. */
residue
        :   INTEGER
            residue_specification
            SEMICOLON
        ;
   
   
/** 
*   Rule for a single residue, which may be either a monosaccharide, 
*   a substituent, or one of the other types specified by GlycoCT 
*   (ie: INCHI, freetext).
*/
residue_specification
        :   monosac_specification
        |   substit_specification
        //|   inchi_specification // TODO later
        ;

/** 
*   Rule that tests whether a residue is a monosaccharide. 
*   "Monosaccharide-ness" is implied by matching lexer rule 
*   MONOSAC_DECLARATION.
*/
monosac_specification
        :
            MONOSAC_DECLARATION    
            monosaccharide
        ;

/** 
*   Rule that tests whether a residue is a substituent. 
*   "Substituent-ness" is implied by matching lexer rule 
*   SUBSTIT_DECLARATION.
*/
substit_specification
        :
            SUBSTIT_DECLARATION   
            substituent_name
        ;

/** 
*   Rule for a monosaccharide, in GlycoCT format, consisting of a 
*   monosaccharide name, its superclass, ring closure positions, 
*   and a list of modifications at each terminus, if any. 
*/
monosaccharide                                  //{   ResidueToken n; Token c; }
        :   //ANOMER                            
            //HYPHEN
            n=monosaccharide_name               {   self.addResidue( n );  } //{   addResidue( n );  }
            HYPHEN
            monosac_superclass                
            HYPHEN
            monosac_ring_closure              
            (monosac_modifications)*
        ;


/** 
*   Rule for a monosaccharide name. A monosaccharide name in GlycoCT
*   is basically its stem-type, that is, the name/type given to the 
*   basic monosaccharide sans mods, eg: glc. Note that there may be 
*   multiple stem-types given, separated by hyphens.
*
*   Note also that for the purposes of this rule, anomeric config is 
*   considered part of the monosaccharide name.
*/
monosaccharide_name returns [m] //[ResidueToken m = null]
        :   n:IDENTIFIER                    
            ( 
                HYPHEN 
                x:IDENTIFIER                    {   n.setText( n.getText() + "-" + x.getText() );  } 
            )*                                  {   m = self.createResidueToken( n );  } //{   m = createResidueToken( n );  }                                      
        ; 
        
/** 
*   Rule for a substituent name (ie: non-monosaccharide). 
*   A substituent name may be any hyphen-separated list of identifiers.
*/
substituent_name
        :   n:IDENTIFIER                        
            (
                HYPHEN 
                x:IDENTIFIER                    {   n.setText( n.getText() + "-" + x.getText() );  }
            )*                                  {   self.addResidue( self.createResidueToken( n ) );  } //{   addResidue( createResidueToken( n ) );  }
        ;
    

/** 
*   Rule for ring size/configuration, eg: hex (for hexose), hept (for heptose). 
*
*   The fact that all alts of this rule are literal strings means that 
*   ALL incidences of these strings in input text will be interpreted as 
*   a monosac_superclass (literal) token, which will in most situations 
*   produce a syntax exception. 
*
*   This means that this effectively precludes these strings being used
*   as monosaccharide or substituent names, which I believe is the 
*   correct behaviour.
*/
monosac_superclass
        :                                       { c = self.LT(1); } //{   Token c = LT(1);  }
        (   "hex"       // hexose (6)
        |   "pen"       // pentose (5)
        |   "hept"      // heptose (7)
        |   "non"       // nonulose (8)
        )                                       {   self.setSuperclass( c );  }  //{   setSuperclass( c );  }
        ;

/**
*   Rule for GlycoCT monosaccharide ring closure syntax, of form 
*   "<terminus_position>-<terminus_position>".
*/
monosac_ring_closure
        :                                       
            t1:INTEGER                   
            COLON
            t2:INTEGER                          {   self.setRingClosure( t1, t2 );  } //{   setRingClosure( t1, t2 );  }           
        ;
   
/**
*   Rule defining a valid terminus position, which may be
*   either a positive integer, or the unknown symbol ('x').
*/
terminus_position returns [t] //[Token t]
        :   
            i:INTEGER                           {  t = i;  }                           
        |   u:UNKNOWN_TERMINUS                  {  t = u;  } 
        ;

/**
*   Rule for a monosaccharide modification list, which may be 
*   a pipe-symbol ('|') delimited list of monosaccharide 
*   modifications. The general form of a monosac modification is
*   "<terminus_position>:<identifier>". Modifications that affect
*   2 terminii (such as double or triple bonds) are also matched
*   by this rule.
*/
monosac_modifications
        :   
            PIPE
            t1:INTEGER 
            ( COMMA t2:INTEGER )? // syntax for alkenes is '|2,3:en' 
            COLON
            n:IDENTIFIER                      {   self.addModification( n, t1, t2 );  } //{   addModification( n, t1, t2 );  }
        ;
    
/*
monosac_modification
        :   //IDENTIFIER
        (   "d"         //  deoxygenation  
        |   "keto"      //  a carbonyl group 
        |   "en"        //  double-bond       
        |   "enx"       //  double-bond?   
        |   "a"         //  acidic group    
        |   "aldi"      //  reduced C1 carbonyl
        |   "sp2"       //  outgoing linkage with double bond 
        |   "geminal"   //  2 OH at one backbone carbon 
        )
        ;
*/


/*
monosac_type_identifier
        :   //t:LETTER                            {  check validity here   }
        (   "b"     //  a base type  
        |   "s"     //  a substituent 
        |   "n"     //  other chemically defined entity (freetext) 
        |   "i"     //  INCHI-encoded non-basetype, non-substituent 
        |   "r"     //  repeating unit 

//  ERROR in the specification: 's' is duplicated
//        |   "s"     //  statistical unit
        )
        ;
*/


//~~~  LIN SECTION  ~~~//

/** Rule matching a single linkage declaration. */
linkage                                         //{  Token lnrt; Token lrt;  }                                      
        :
        //  linkage numbering order
        i:INTEGER
        COLON
        
        //  non-reducing residue id + type
        nrti:INTEGER
        nrtt:IDENTIFIER 

        //  then the actual linkage             
        LPARENTHESIS
        lnrt=terminus_position
        HYPHEN
        lrt=terminus_position
        RPARENTHESIS
        
        //  then the reducing residue id + type
        rti:INTEGER
        rtt:IDENTIFIER    

        //  end of linkage
        SEMICOLON                           {   self.addLinkage( i, nrti, nrtt, lnrt, lrt, rti, rtt );  } //{   addLinkage( i, nrti, nrtt, lnrt, lrt, rti, rtt );  }
        ;

/*
linkage_type_identifier returns [Token type]
        :   //t:LETTER                            {  // check validity here // type = t; }
        (   "o"     //  loss of H from OH 
        |   "h"     //  loss of H
        |   "d"     //  loss of OH 
        |   "n"     //  linkage to non-monosac/repeat
        |   "r"     //  prochiral H-atom removed, resulting in R-configuration 
        |   "s"     //  prochiral H-atom removed, resulting in S-configuration 
        )                                       {   type = LT(1);  }
        ;    
*/

/*
anomer //returns [Anomer a]            
        //:   t:LETTER                            {  a = checkAnomer( t );  }
        :   "a"       //  alpha       
        |   "b"       //  beta        
        |   "o"       //  open-chain  
        |   "x"       //  unknown             
        ;
*/

/*
stereo
        :
        (   "d"       //  dextro  
        |   "l"       //  levo    
        |   "x"       //  unknown 
        )
        ;
*/

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LEXER  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
/**
*
*   This class implements a lexer/scanner for carbohydrate
*   sequences in Glycoct syntax. This class was auto-generated from
*   the ANTLR lexer grammar in glycoct_grammar.g.
*
*   @see GlycoctParser
*   @see glycoct_grammar.g
*
*   @author mjh [matt@ebi.ac.uk]
*/
class GlycoctLexer extends Lexer;

options {
    k=3;        /*  lookahead  */
}

//~~~~~~~~~~~~~~~~~~~~  token separators & delimiters  ~~~~~~~~~~~~~~~~~~~~~~//
    
/** A literal colon ':' */
COLON
        options { paraphrase="a colon separator ':'"; }
        :   ':'
        ;
     
/** A literal comma ',' */
COMMA                
        options { paraphrase="a comma ','"; }
        :     ','
        ;

/** A literal hyphen '-' */
HYPHEN            
        options { paraphrase="a hyphen '-'"; }
        :     '-' 
        ;

/** A literal pipe symbol '|' */
PIPE                
        options { paraphrase="a residue substitution delimiter '|'"; }
        :     '|'
        ;

/** A literal semicolon ';' */
SEMICOLON
        options { paraphrase="a residue/linkage token separator ';'"; }
        :   ';'
        ;
        
/** A literal left parenthesis '(' */
LPARENTHESIS
        options { paraphrase="a linkage start delimiter '('"; }
        :   '('
        ;
        
/** A literal right parenthesis ')' */
RPARENTHESIS
        options { paraphrase="a linkage end delimiter ')'"; }
        :   ')'
        ;
        
/** A literal '?', indicating an unknown terminal position. */
UNKNOWN_TERMINUS
        options { paraphrase="an unknown terminal position '?'"; }
        :   '?'                                
        ;
        
//~~~~~~~~~~~~~~~~~~~~~~~~~~~ identifiers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//


/** A literal string "b:", which declares a following monosaccharide section. */
MONOSAC_DECLARATION
        options { paraphrase="a basetype declaration 'b:'"; }
        :   "b:"
        ;

/** A literal string "s:", which declares a following substituent section. */
SUBSTIT_DECLARATION
        options { paraphrase="a substituent declaration 's:'"; }
        :   "s:"
        ;

/** A literal string "i:", which declares a section of INCHI code. */
INCHI_DECLARATION
        options { paraphrase="an inchi section declaration 'i:'"; }
        :   "i:"
        ;

/*  
ANOMER 
        :   'a'       //  alpha       
        |   'b'       //  beta        
        |   'o'       //  open-chain  
        |   'x'       //  unknown             
        ;
*/

/*
LINKAGE_TYPE_IDENTIFIER 
        :   
        (   'o'     //  loss of H from OH 
        |   'h'     //  loss of H
        |   'd'     //  loss of OH 
        |   'n'     //  linkage to non-monosac/repeat
        |   'r'     //  prochiral H-atom removed, resulting in R-configuration 
        |   's'     //  prochiral H-atom removed, resulting in S-configuration 
        )                                      
        ;    
*/

/*
LINKAGE_TERMINUS_DECLARATION
        :   INTEGER  LINKAGE_TYPE_IDENTIFIER
        ;
*/
 
/*
MONOSAC_MODIFICATION
        :  
        (   "d"         //  deoxygenation  
        |   "keto"      //  a carbonyl group 
        |   "en"        //  double-bond       
        |   "enx"       //  double-bond?   
        |   "a"         //  acidic group    
        |   "aldi"      //  reduced C1 carbonyl
        |   "sp2"       //  outgoing linkage with double bond 
        |   "geminal"   //  2 OH at one backbone carbon 
        )
        ;
*/
/*
MONOSAC_SUPERCLASS
        :  
        (   "hex"       // hexose (6)
        |   "pen"       // pentose (5)
        |   "hept"      // heptose (7)
        |   "non"       // nonulose (8)
        )
        ;
*/

/** Rule for a (positive) integer, or zero. */
INTEGER
        options { paraphrase="a positive integer or zero"; }
        :   ('1'..'9')  ('0'..'9')*  
        |   '0'
        ;
        
        
/** Rule for an identifier, which may be any alphabetic string. */
IDENTIFIER                    
        options { paraphrase="an alphabetic identifier"; }
        :   ('a'..'z')+                         //{   if ($getText == "x") { $setType(UNKNOWN_TERMINUS); }  }
        ;

/*
protected UNKNOWN_TERMINUS
        options { paraphrase="an unknown terminus position"; }
        :   'x'
        ;
*/

//~~~~~~~~~~~~~~~~~~~~~~~  section type identifiers  ~~~~~~~~~~~~~~~~~~~~~~~~//

/** Rule for a literal string "RES", identifying a RES section. */
RES
        options { paraphrase="a RES (residue) section start identifier"; }
        :   "RES"
        ;
        
/** Rule for a literal string "LIN", identifying a LIN section. */
LIN     
        options { paraphrase="a LIN (linkage) section start identifier"; }
        :   "LIN" 
        ;
        
/** Rule for a literal string "PRO", identifying a PRO section. */
PRO     
        options { paraphrase="a PRO (heterogeneity due to uncertainty) section start identifier"; }
        :   "PRO"
        ;
        
/** Rule for a literal string "REP", identifying a REP section. */
REP     
        options { paraphrase="a REP (repeat) section start identifier"; }
        :   "REP"
        ;
        
/** Rule for a literal string "STA", identifying a STA section. */
STA 
        options { paraphrase="a STA (heterogeneity due to a statistical distribution) section start identifier"; }
        :   "STA"
        ;
        
/** Rule for a literal string "ISO", identifying a ISO section. */
ISO
        options { paraphrase="an ISO (isotope) section start identifier"; }
        :   "ISO"
        ;
        
/** Rule for a literal string "AGL", identifying a AGL section. */
AGL
        options { paraphrase="an AGL (aglycon) section start identifier"; }
        :   "AGL"
        ;
        
    
/** 
*   The "whitespace" rule, comprising space, tab, and return. 
*   These tokens are disregarded when parsing. 
*/
WS  
        : 
        (   ' '
        |   '\t' 
        |   (( '\r' '\n' ) | '\n')              {   self.newline();  } //{   newline();  }
        )                                       {   $setType( Token.SKIP );  }
        ;
          